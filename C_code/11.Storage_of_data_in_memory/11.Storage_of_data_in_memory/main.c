#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

//一、整数在内存中的存储
//整数的二进制表示有三种，即原码、反码、补码
//有符号整数，三种表示方法均有符号位和数值位两部分，符号位0表示正，1表示负
//最高位的一位是被当作符号位，剩余的都是数值位
//整数的原反补码都相同
//而负整数的原反补码需要计算
//原码：直接将数值按照正负数的形式翻译成二进制得到的就是原码
//反码：将原码的符号位不变，其他位依次按位取反
//补码：反码+1
//对整型来说，数据在内存中其实存放的是二进制的补码




//二、大小端字节序
//超过一个字节的数据在内存中存储的时候，就有存储顺序的问题
//按照不同的存储顺序，可以分为大端字节序和小端字节序
//大端存储：数据的低位字节存储在内存中的高地址处，高位字节存储在内存的低地址处
//小端存储：数据的低位字节存储在内存中的低地址处，高位字节存储在内存的高地址处
//int main()
//{
//	int n = 0x11223344;
//	//内存中：44 33 22 11 -- 在VS下，是小端存储
//	return 0;
//}


//练习1：设计一个小程序来判断当前机器是大端还是小端
//int main()
//{
//	int a = 1;
//	//小端：01 00 00 00
//	//大端：00 00 00 01
//	int* pa = &a;
//	if (*(char*)pa == 1)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大端\n");
//	}
//
//	return 0;
//}


//练习2：
//int main()
//{
//	char a = -1;
//	//10000000000000000000000000000001 -- 原码
//	//11111111111111111111111111111111 -- 补码
//	//11111111 -- 截取8位存入a
//	//11111111111111111111111111111111 -- 整型提升（补码）
//	//10000000000000000000000000000001 -- 原码 == -1
//
//	signed char b = -1;
//	//10000000000000000000000000000001 -- 原码
//	//11111111111111111111111111111111 -- 补码
//	//11111111 -- 截取8位存入b
//	//11111111111111111111111111111111 -- 整型提升（补码）
//	//10000000000000000000000000000001 -- 原码 == -1
//
//	unsigned char c = -1;
//	//10000000000000000000000000000001 -- 原码
//	//11111111111111111111111111111111 -- 补码
//	//11111111 -- 截取8位存入c
//	//00000000000000000000000011111111 -- 整型提升（补码、原码）== 255
//
//	printf("a=%d,b=%d,c=%d\n", a, b, c);
//	return 0;
//}


//练习3：
//int main()
//{
//	char a = -128;
//	//10000000000000000000000010000000 -- 原码
//	//11111111111111111111111101111111 -- 反码
//	//11111111111111111111111110000000 -- 补码
//	//10000000 -- 截取8位存入a
//	//11111111111111111111111110000000 -- 整型提升
//	printf("%u\n", a);
//	return 0;
//}


//练习4：
//int main()
//{
//	char a = 128;//实际放的是-128
//	//00000000000000000000000010000000 -- 原、反、补
//	//10000000 -- 截取8位存入a
//	//11111111111111111111111110000000 -- 整型提升
//	printf("%u\n", a);
//	return 0;
//}


//练习5：
//int main()
//{
//	char a[1000];
//	int i = 0;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//		//-1 -2 -3......-128 127 126 .....1 0
//	}
//	printf("%d", strlen(a));
//	return 0;
//}


//练习6：
//unsigned char i = 0;
//int main()
//{
//	for (i = 0; i <= 255; i++)
//	{
//		printf("Hello World\n");//死循环
//	}
//	return 0;
//}


//练习7：
//int main()
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%u\n", i);//死循环
//	}
//	return 0;
//}


//练习8：
//x86环境，小端字节序
//int main()
//{
//	int a[4] = { 1,2,3,4 };
//	int* ptr1 = (int*)(&a + 1);
//	int* ptr2 = (int*)((int)a + 1);
//
//	printf("%x,%x\n", ptr1[-1], *ptr2);
//	return 0;
//}




//三、浮点数在内存中的存储
//int main()
//{
//	float f = 5.5f;
//	//S = 0
//	//E = 2
//	//M = 1.011
//	//0 10000001 01100000000000000000000
//	//0100 0000 1011 0000 0000000000000000
//	//0x40 b0 00 00
//	return 0;
//}